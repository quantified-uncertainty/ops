# Staging Environment Setup Steps

## Phase 1: Terraform Configuration ✅ DONE
1. ✅ Create terraform/stacks/staging/ directory
2. ✅ Create terraform configuration files:
   - terraform.tf (providers and backend)
   - main.tf (project and locals)
   - k8s.tf (smaller cluster config)
   - db.tf (smaller database config)
   - outputs.tf (cluster and db info)

## Phase 2: GitHub Actions ✅ DONE
1. ✅ Create .github/workflows/staging-control.yml
2. ⏳ Add required GitHub secrets:
   - OP_SERVICE_ACCOUNT_TOKEN
   - AWS_ACCESS_KEY_ID (for terraform backend)
   - AWS_SECRET_ACCESS_KEY (for terraform backend)

## Phase 3: Local Testing First
1. ⏳ Test terraform locally in dev environment:
   ```bash
   cd terraform/stacks/staging
   terraform init
   terraform plan
   terraform apply
   ```
2. ⏳ Verify cluster and database creation
3. ⏳ Configure kubectl access: `doctl kubernetes cluster kubeconfig save staging`
4. ⏳ Test basic cluster functionality
5. ⏳ Destroy when satisfied: `terraform destroy`

## Phase 4: GitHub Actions Integration
1. ⏳ Add required GitHub secrets:
   - OP_SERVICE_ACCOUNT_TOKEN
   - AWS_ACCESS_KEY_ID (for terraform backend)
   - AWS_SECRET_ACCESS_KEY (for terraform backend)
2. ⏳ Test GitHub Actions workflow with action=create
3. ⏳ Verify GitHub Actions can create/destroy successfully

## Phase 5: DNS Configuration
1. ⏳ Set up DNS records for staging domains:
   - staging.roast-my-post.com
   - staging.squiggle-language.com  
   - staging.getguesstimate.com
2. ⏳ Point to staging cluster load balancer

## Phase 6: ArgoCD Integration
1. ⏳ Create staging ArgoCD applications
2. ⏳ Configure staging ingress domains
3. ⏳ Test application deployments to staging

## Phase 7: Final Validation
1. ⏳ Deploy roast-my-post to staging
2. ⏳ Verify staging.roast-my-post.com works
3. ⏳ Test full create/destroy cycle via GitHub Actions
4. ⏳ Document final workflow for team

## Next Immediate Steps:
1. ✅ Run terraform locally to test staging infrastructure:
   a. ✅ cd terraform/stacks/staging
   b. ✅ terraform init
   c. ✅ terraform plan (review what will be created)
   d. ✅ terraform apply (create the infrastructure)
   e. ✅ doctl kubernetes cluster kubeconfig save staging
   f. ✅ kubectl config use-context do-nyc1-staging
   g. ✅ kubectl get nodes (verify cluster is working)
   h. ✅ terraform destroy (clean up when done testing)
2. ✅ Fix any issues found during local testing
3. ⏳ Once working locally, set up GitHub Actions

## Phase 8: Automated Infrastructure Apps Deployment
1. ✅ Infrastructure apps are now deployed automatically by Terraform:
   a. ✅ Terraform applies ArgoCD during cluster creation
   b. ✅ Terraform deploys staging app-of-apps automatically
   c. ✅ ArgoCD syncs all infrastructure apps automatically:
      - cert-manager-staging (for TLS certificates)
      - ingress-nginx-staging (for ingress controller)  
      - metrics-server-staging (for HPA and resource metrics)
      - prometheus-staging (lightweight monitoring for staging)
      - loki-staging (log aggregation with local storage)
      - roast-my-post-staging (application deployment)

2. ⏳ Verify automated deployment worked:
   a. Check cluster is ready: `kubectl get nodes`
   b. Access ArgoCD: `kubectl port-forward svc/argocd-server -n argocd 8080:443`
   c. Open https://localhost:8080 (accept self-signed cert)
   d. Get admin password: `kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d`
   e. Verify all apps are synced and healthy in ArgoCD UI

3. ⏳ Configure staging-specific secrets:
   a. Create staging database secrets: `kubectl create secret generic roast-my-post-env -n staging --from-literal=DATABASE_URL="$(terraform output -raw database_connection_pool)"`
   b. Verify all infrastructure apps are healthy: `kubectl get applications -n argocd`

4. ⏳ Set up staging DNS records:
   a. Get ingress controller external IP: `kubectl get svc -n ingress-nginx ingress-nginx-controller`
   b. Create DNS records pointing staging.roast-my-post.com to cluster IP

5. ⏳ Test end-to-end staging environment:
   a. Verify cert-manager is issuing certificates: `kubectl get certificates -A`
   b. Check roast-my-post deployment: `kubectl get pods -n staging`
   c. Access staging application at https://staging.roast-my-post.com
   d. Check Grafana at staging grafana domain (admin/staging123)
   e. Verify logs are flowing to Loki

## Phase 9: Application Deployment to Staging
1. ⏳ Deploy roast-my-post to staging:
   a. Create staging-specific values file for roast-my-post
   b. Configure staging database connection
   c. Deploy via ArgoCD
   d. Verify application is accessible at staging.roast-my-post.com
2. ⏳ Test staging environment end-to-end:
   a. Verify application functionality
   b. Check monitoring and logging
   c. Test autoscaling behavior
   d. Validate backup and restore procedures

## Phase 10: CI/CD Integration
1. ⏳ Set up GitHub Actions for staging deployments:
   a. Create staging deployment workflow
   b. Configure automatic deployments on main branch
   c. Set up staging environment promotion workflow
2. ⏳ Document staging workflow for team:
   a. How to deploy to staging
   b. How to promote from staging to production
   c. Troubleshooting guide
